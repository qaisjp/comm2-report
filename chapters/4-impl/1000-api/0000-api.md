# API Design {#sec:design-api}

List of endpoints table, TODO

## Versioning

(rooted at `/v1/`)

## Consuming our own API

For the following reasons, our frontend uses MTA Hub's own public API wherever possible:

- It will ensure we "spend the time to architect and proof out an API that will stay around for a while" and prevent us from "updating the API frequently" [@eversShouldWebsiteUse2012].
- Dante says "Unless the performance overhead of using the web service is an issue, you should definitely use your public API. This will help you get a consistent behavior between your application and the consumers. It will also avoid code duplication [...]" [@danteArchitectureHowMy2013]

Since our API is REST-compliant and the endpoints are organised specific to _entities_, and not to specific webpages on the frontend, some webpages on the frontend will need to make multiple requests to MTA Hub's API to display all the information necessary.

Making multiple API requests can cause a webpage to take a while to load. For example, to fetch the user's profile we would need to first request `/v1/users/qaisjp` to check that the user exists and get their basic information, and then query `/v1/users/qaisjp/resources` to list their resources.

To avoid making extra requests and to improve performance, we have chosen implement a number of _private_ endpoints for internal use only. This will allow us to "make data access more performant by using the database directly instead of doing extra requests" [@virkkunenApiDesignIt2010]. These internal endpoints live at `/private/` instead of the regular `/v1/` prefix, discouraging those that reverse engineer our webapp from building software using these endpoints.

<!-- other links: TODO
- https://softwareengineering.stackexchange.com/questions/332864/fully-api-based-website-is-it-a-good-idea -->

## Permission management

We decided that permissions will be granular for site administrators,
but kept simple on a resource level. Original creators of a resource retain
permanent access rights to a resource and can also designate additional resource
administrators. These designated resource admins have all the same
permissions as the creator.

TODO: why?

## Deletions

A common approach to deleting entities in webapps is
to set an `is_deleted` flag to `true` and simply hide the row from
output.

This is useful if we need to maintain an audit log or (considering that
deletions are destructive) would like to undo changes.

Users, however, may not appreciate a website holding onto data they've
requested to be deleted.

When deleting _resources_ we can just run an SQL query like `delete from resources where resource_id = ?`
and let PostgreSQL cascade this via foreign keys.

Doing this for users raises the following questions:

1. When the user requests a deletion, their comments should be anonymised instead of outright removed (todo: why?)
2. When an admin deletes the account, the admin should decide whether or not their comments should be removed too. This allows admins to easily purge content from spammers.
3. What if an admin  post-comment-retaining-deletion, that
    their posts should have indeed been deleted?

(TODO) Deletions could:

- For comments and bans, allow `author_id` to be nullable. Show `[deleted]` in place.
    - This means we lose track of who the author was.
    - Reddit does this.
- When deleting user accounts, delete all the associated data, but keep the user row, and set `is_deleted` to true. We should also remove all personal data.
    - We also need to litter `if user.is_deleted then` everywhere

This is in line with the General Data Protection Regulation (GDPR) as only personally identifiable information needs to be removed. Comments do not contain sensitive data, and do not fall under the GDPR.

<!-- ### HTTP Stuff, again

Hyphens - The standard best practice for REST APIs is to have a hyphen, not camelcase or underscores. - This comes from Mark Masse's "REST API Design Rulebook" from Oreilly. -->
