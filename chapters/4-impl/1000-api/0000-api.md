# API {#sec:design-api}

This section describes how the API was implemented. Note that appendix B lists all the endpoints that were implemented.

## Versioning

Throughout the lifetime of MTA Hub we may choose to make breaking changes such as deprecating or changing the behaviour of certain API endpoints. We have implemented a versioning strategy that, when we make breaking API changes, "allows clients to continue using the existing REST API and migrate their applications to the newer API when they are ready" [@FourRESTAPI].

All of our endpoints are prefixed with the version number, for example `/v1/users` to get the list of users. In the future, if we choose to change how our API is designed, we can root those new endpoints under the `/v2` path. Note that this is the same approach that GitHub and the Rust Package Registry have implemented, as discussed in @sec:bg-api-analysis.

## JSON Web Tokens (JWT) {#sec:api-jwt}

We use JWT to handle stateless authentication.

> "JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties." [@JWTIO]

This allows us to cryptographically trust that users are who they say they are, as we can verify the token's signature. This signature is generated by a private key that only we (the trusted server) have access to.

Stateless authentication means that we do not need to store tokens in our database and helps improve REST-compliancy.

We use a middleware library to process and generate JWTs, and have not written this component ourselves.

## Middleware

We built a number of helper functions ("middleware") to centralise input validation and permission checks. This helps reduce copy-and-pasting code by only having one copy of a validator, and improves security by checking permissions at the time paths are being routed to the relevant functions.

Generally, middleware functions allow us to include generic logic that is executed before the main route handler is processed. This means we can inject additional information into the request context (to include information about the authenticated user), or prevent the route handler from being executed altogether (to raise an error if the user isn't logged in).

### Authentication

As mentioned in [@sec:api-jwt], a third-party library provides us with middleware to handle JWT authentication. We chose to build our own middleware functions that wrap around the middleware provided by the third-party library, as described below.

We initially created these two middleware functions to help with authentication:

-   `authRequired`: this function is returned by the JWT library:

    ```go
    authRequired := authMiddleware.MiddlewareFunc()
    ```

    Any route that includes this
    middleware function requires the request to have an associated authenticated
    user.
-   `authMaybeRequired`: this function checks that an
    authentication token is provided, and if so, verifies the user using `authRequired`). If not, it sets the `user` context variable to `nil`. This is useful for endpoints that behave differently if the user is logged in.

This works well when `authMaybeRequired` isn't used frequently, but we discovered that a lot of our routes needed to use `authMaybeRequired`. Some entities may be private, and therefore only accessible to resource authors and site admins.

We decided to change to three middleware functions:

-   `authMiddlewareFunc`: this is returned by the JWT library
    via `authMiddleware.MiddlewareFunc()`, as `authRequired` above
-   `authMaybeRequired`: this is the same as above except it verifies
    the user using `authMiddlewareFunc`. This middleware is run **for all endpoints**.
-   `authRequired`: this function aborts if the `user` context variable is `nil`, and sends a response containing:

    -   the header `*WWW-Authenticate` to `JWT realm=multitheftauto.com`,
    -   the status code to `401 Status Unauthorized`, and
    -   the body `{"message": "You must be logged in to perform that operation."}`

This means that:

- All routes process requests that include an authorisation token, through the globally applied `authMaybeRequired` function.
- If a route should only be accessible to authenticated users, we can apply the `authRequired` middleware function for that route.

### Parameter validation

Route URLs can include placeholders such as `:user_id`, so that the route handler can easily extract parameters from the URL. We have built two middleware functions to ensure that these IDs map to valid entities in the database.

**`checkUser`**

As shown in [@lst:api-checkUser], the `checkUser` middleware function ensures that there is always a valid user entity in the database for the `user_id` URL parameter:

- First we get the `user_id` parameter and store the value in a generic `fieldVal` variable. We also declare `fieldName` to be a `"username"` string, since we search by username by default.
- If the `fieldVal` variable can be parsed as a valid unsigned integer, then we assign the integer to the previously declared `fieldVal`. We also update the `fieldName` from `"username"` to `"id"`.
- We then search the database, comparing the dynamically set field name against the generic field value. This means that if the `user_id` parameter was "2", the `where` clause would be `where id = 2`. If the `user_id` parameter was "bob", the `where` clause would be `where username = 'bob'`.
- If the database query failed, our middleware function aborts the request.
- If the query was successful, we set the context variable `"user"` to the retrieved user structure.

```go
func (a *API) checkUser(c *gin.Context) {
	var fieldVal interface{} = c.Param("user_id")
	fieldName := "username"
	userID, err := strconv.ParseUint(c.Param("user_id"), 10, 64)
	if err == nil {
		fieldVal = userID
		fieldName = "id"
	}

	// Check if the user exists
	var user User
    if err := a.DB.Get(&user,
        "select * from users where "+pq.QuoteIdentifier(fieldName)+" = $1",
        fieldVal,); err != nil {
		// verbose error handling has been commented out
		c.Abort()
		return
	}

	// Store the resource
	c.Set("user", &user)
}
```

: Implementation of `checkUser` with support for falling back on a username, rather than a numerical user ID. {#lst:api-checkUser}

We also have a `checkResource` middleware function that behaves in a near-identical way, except that database query requires the author of the resource to be equal to the ID of the user stored in the `"user"` context variable.

**`parseUserID`**

Some of our endpoints interact with multiple users at a time, so we have created a function `parseUserID` that _returns_ a middleware function, given a parameter that must be checked. The signature of that function is as follows:

```go
func (*API) parseUserID(param string, key string, abort bool) MiddlewareFunc
```

: sds sd sd {#lst:api-parseuserid}



- The `param` argument determines which parameter to read from the URL.
- The `key` argument determines which context variable to store the corresponding user in.
- Setting the `abort` argument will cause the middleware to abort if the database query returned no users. Setting this to `false` is similar to the behaviour of `authMaybeRequired`, and setting this to `true` is similar to the behaviour of `authRequired`.

### Resource permissions

Our final middleware function, `mustManageResource`, performs the following checks:

1. Ensures that the user is authenticated.
2. Checks whether the current user _can manage_ the given resource.

The `canUserManageResource(context, userID, resourceID)` helper function is a core permission check that is used in many places throughout our API, and works as follows:

- If resource data is already stored in our context via `checkResource`, and that resource matches the given `resourceID` argument:
    - Return `true` if the resource creator matches `userID`, otherwise
    - Perform a database query, checking the `resource_collaborators` table only.
- Otherwise, check both the resource's creator ID and the list of resource collaborators using the SQL query in [@lst:api-canmanage-query].

```sql
    select true from resource_collaborators where
        accepted and resource_id = $1 and user_id = $2
union distinct
    select true from resources where
        id = $1 and author_id = $2
```

: SQL query that checks if a user (ID `$2`) can manage a resource (ID `$1`).  {#lst:api-canmanage-query}

This multi-tier check allows us to avoid unnecessary SQL queries or table lookups if we are certain that the given user did or did not create the resource.


## Consuming our own API

For the following reasons, our frontend uses MTA Hub's own public API wherever possible:

- It will ensure we "spend the time to architect and proof out an API that will stay around for a while" and prevent us from "updating the API frequently" [@eversShouldWebsiteUse2012].
- Dante says "Unless the performance overhead of using the web service is an issue, you should definitely use your public API. This will help you get a consistent behavior between your application and the consumers. It will also avoid code duplication [...]" [@danteArchitectureHowMy2013]

Since our API is REST-compliant and the endpoints are organised specific to _entities_, and not to specific webpages on the frontend, some webpages on the frontend will need to make multiple requests to MTA Hub's API to display all the information necessary.

Making multiple API requests can cause a webpage to take a while to load. For example, to fetch the user's profile we would need to first request `/v1/users/qaisjp` to check that the user exists and get their basic information, and then query `/v1/users/qaisjp/resources` to list their resources.

To avoid making extra requests and to improve performance, we chose to implement a number of _private_ endpoints for internal use only. This will allow us to "make data access more performant by using the database directly instead of doing extra requests" [@virkkunenApiDesignIt2010]. These internal endpoints live at `/private/` instead of the regular `/v1/` prefix, discouraging those that reverse engineer our webapp from building software using these endpoints.

<!-- other links:
- https://softwareengineering.stackexchange.com/questions/332864/fully-api-based-website-is-it-a-good-idea -->

<!-- ### HTTP Stuff, again

Hyphens - The standard best practice for REST APIs is to have a hyphen, not camelcase or underscores. - This comes from Mark Masse's "REST API Design Rulebook" from Oreilly. -->
